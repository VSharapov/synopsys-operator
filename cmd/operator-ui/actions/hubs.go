package actions

import (
	"fmt"
	"strings"

	"github.com/blackducksoftware/perceptor-protoform/pkg/api/hub/v1"
	hubclientset "github.com/blackducksoftware/perceptor-protoform/pkg/hub/client/clientset/versioned"
	"github.com/blackducksoftware/perceptor-protoform/pkg/util"
	"github.com/gobuffalo/buffalo"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Hub)
// DB Table: Plural (Hubs)
// Resource: Plural (Hubs)
// Path: Plural (/hubs)
// View Template Folder: Plural (/templates/hubs/)

// HubsResource is the resource for the Blackduck model
type HubsResource struct {
	buffalo.Resource
	kubeClient *kubernetes.Clientset
	hubClient  *hubclientset.Clientset
}

// NewHubResource will instantiate the Black Duck Resource
func NewHubResource(kubeConfig *rest.Config) (*HubsResource, error) {
	kubeClient, err := kubernetes.NewForConfig(kubeConfig)
	if err != nil {
		return nil, fmt.Errorf("unable to create kube client due to %+v", err)
	}
	hubClient, err := hubclientset.NewForConfig(kubeConfig)
	if err != nil {
		return nil, fmt.Errorf("unable to create hub client due to %+v", err)
	}
	return &HubsResource{kubeClient: kubeClient, hubClient: hubClient}, nil
}

// List gets all Hubs. This function is mapped to the path
// GET /hubs
func (v HubsResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	// tx, ok := c.Value("tx").(*pop.Connection)
	// if !ok {
	// 	return errors.WithStack(errors.New("no transaction found"))
	// }
	blackducks, _ := util.ListHubs(v.hubClient, "")

	// // Paginate results. Params "page" and "per_page" control pagination.
	// // Default values are "page=1" and "per_page=20".
	// q := tx.PaginateFromParams(c.Params())

	// // Retrieve all Blackducks from the DB
	// if err := q.All(blackducks); err != nil {
	// 	return errors.WithStack(err)
	// }

	// // Add the paginator to the context so it can be used in the template.
	// c.Set("pagination", q.Paginator)
	// c.Set("hubs", blackducks.Items)
	return c.Render(200, r.Auto(c, blackducks.Items))
}

// Show gets the data for one Hub. This function is mapped to
// the path GET /hubs/{hub_id}
func (v HubsResource) Show(c buffalo.Context) error {
	blackduck, _ := util.GetHub(v.hubClient, c.Param("hub_id"), c.Param("hub_id"))
	c.Set("hub", blackduck)
	return c.Render(200, r.HTML("hubs/show.html"))
}

// New renders the form for creating a new Hub.
// This function is mapped to the path GET /hubs/new
func (v HubsResource) New(c buffalo.Context) error {
	hub := &v1.Hub{}
	var storageList map[string]string
	storageList = make(map[string]string)
	storageClasses, err := util.ListStorageClass(v.kubeClient)
	if err != nil {
		c.Error(404, fmt.Errorf("\"message\": \"Failed to List the storage class due to %+v\"", err))
	}
	for _, storageClass := range storageClasses.Items {
		storageList[fmt.Sprintf("%s (%s)", storageClass.GetName(), storageClass.Provisioner)] = storageClass.GetName()
	}
	storageList[fmt.Sprintf("%s (%s)", "None", "Disable dynamic provisioner")] = "none"
	hub.View.StorageClasses = storageList
	// c.Set("storageClasses", storageList)

	keys, _ := util.ListHubPV(v.hubClient, "")
	hub.View.Clones = keys
	// c.Set("clones", keys)

	blackducks, _ := util.ListHubs(v.hubClient, "")
	certificateNames := []string{"default", "manual"}
	for _, blackduck := range blackducks.Items {
		if strings.EqualFold(blackduck.Spec.CertificateName, "manual") {
			certificateNames = append(certificateNames, blackduck.Spec.Namespace)
		}
	}
	hub.View.CertificateNames = certificateNames
	// c.Set("certificateNames", certificateNames)
	environs := []string{"IPV4_ONLY:0", "HUB_PROXY_NON_PROXY_HOSTS:solr"}
	hub.View.Environs = environs

	return c.Render(200, r.Auto(c, hub))
}

// Create adds a Blackduck to the DB. This function is mapped to the
// path POST /hubs
func (v HubsResource) Create(c buffalo.Context) error {
	// Allocate an empty Blackduck
	hub := &v1.Hub{}

	// Bind blackduck to the html form elements
	if err := c.Bind(hub); err != nil {
		log.Errorf("unable to bind blackduck %+v because %+v", c, err)
		return errors.WithStack(err)
	}

	ns, _ := util.CreateNamespace(v.kubeClient, hub.Spec.Namespace)
	log.Infof("created namespace for %s is %+v", hub.Spec.Namespace, ns)
	log.Infof("create hub: %+v", hub)

	hub, err := util.CreateHub(v.hubClient, hub.Spec.Namespace, &v1.Hub{ObjectMeta: metav1.ObjectMeta{Name: hub.Spec.Namespace}, Spec: hub.Spec})

	if err != nil {
		c.Set("errors", err)
		return c.Render(422, r.Auto(c, hub))
	}
	// If there are no errors set a success message
	c.Flash().Add("success", "Blackduck was created successfully")

	blackducks, _ := util.ListHubs(v.hubClient, "")
	c.Set("hubs", blackducks.Items)
	// and redirect to the blackducks index page
	return c.Render(200, r.HTML("hubs/index.html"))
}

// Edit renders a edit form for a Hub. This function is
// mapped to the path GET /hubs/{hub_id}/edit
func (v HubsResource) Edit(c buffalo.Context) error {
	// Get the DB connection from the context
	// tx, ok := c.Value("tx").(*pop.Connection)
	// if !ok {
	// 	return errors.WithStack(errors.New("no transaction found"))
	// }

	// // Allocate an empty Blackduck
	// blackduck := &v1.Hub{}

	// if err := tx.Find(blackduck, c.Param("blackduck_id")); err != nil {
	// 	return c.Error(404, err)
	// }

	// return c.Render(200, r.Auto(c, blackduck))
	return c.Error(404, errors.New("resource not implemented"))

}

// Update changes a Blackduck in the DB. This function is mapped to
// the path PUT /hubs/{hub_id}
func (v HubsResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	// tx, ok := c.Value("tx").(*pop.Connection)
	// if !ok {
	// 	return errors.WithStack(errors.New("no transaction found"))
	// }

	// // Allocate an empty Blackduck
	// blackduck := &v1.Hub{}

	// if err := tx.Find(blackduck, c.Param("blackduck_id")); err != nil {
	// 	return c.Error(404, err)
	// }

	// // Bind Blackduck to the html form elements
	// if err := c.Bind(blackduck); err != nil {
	// 	return errors.WithStack(err)
	// }

	// verrs, err := tx.ValidateAndUpdate(blackduck)
	// if err != nil {
	// 	return errors.WithStack(err)
	// }

	// if verrs.HasAny() {
	// 	// Make the errors available inside the html template
	// 	c.Set("errors", verrs)

	// 	// Render again the edit.html template that the user can
	// 	// correct the input.
	// 	return c.Render(422, r.Auto(c, blackduck))
	// }

	// // If there are no errors set a success message
	// c.Flash().Add("success", "Blackduck was updated successfully")

	// and redirect to the blackducks index page
	return c.Error(404, errors.New("resource not implemented"))
}

// Destroy deletes a Hub from the DB. This function is mapped
// to the path DELETE /hubs/{hub_id}
func (v HubsResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	// tx, ok := c.Value("tx").(*pop.Connection)
	// if !ok {
	// 	return errors.WithStack(errors.New("no transaction found"))
	// }

	log.Infof("delete hub request %v", c.Param("hub_id"))

	_, err := util.GetHub(v.hubClient, c.Param("hub_id"), c.Param("hub_id"))
	// To find the Blackduck the parameter blackduck_id is used.
	if err != nil {
		return c.Error(404, err)
	}

	// This is on the event loop.
	err = v.hubClient.SynopsysV1().Hubs(c.Param("hub_id")).Delete(c.Param("hub_id"), &metav1.DeleteOptions{})

	// To find the Blackduck the parameter blackduck_id is used.
	if err != nil {
		return c.Error(404, err)
	}

	// if err := tx.Destroy(blackduck); err != nil {
	// 	return errors.WithStack(err)
	// }

	// If there are no errors set a flash message
	c.Flash().Add("success", "Blackduck was deleted successfully")

	blackducks, _ := util.ListHubs(v.hubClient, "")
	c.Set("hubs", blackducks.Items)
	// Redirect to the blackducks index page
	return c.Render(200, r.HTML("hubs/index.html"))
}
